# Лабораторная работа №1 по курсу "Операционные системы"

**Тема:** Файловые системы Linux-подобных ОС

**Автор:** Щеглов Михаил, группа 3381

**Дата выполнения:** март 2025

**ОС:** Debian GNU/Linux 6.1.0-30-amd64

**Процессор:** Intel Core i7-13650HX (20 потоков)

---

## Цель

Ознакомление с типами файлов и структурой файловых систем, правами доступа, системными утилитами анализа, исследование особенностей работы с>

---

## Структура проекта

```plaintext
.
├── 1_lab.pdf           # Условие лабораторной
├── lab1.log            # Основной лог (все задания, выводы, команды)
├── scripts/            # Скрипты для отдельных заданий
│   ├── lab1_task1.sh
│   ├── lab1_task2.sh
│   ├── lab1_task3.sh
│   ├── lab1_task7.sh
│   ├── lab1_task10.c
│   ├── SUID_TEST.c
│   └── suid_test_program

```
---

## Описание заданий

### Задание 1 — Типы файлов
Скрипт `lab1_task1.sh` ищет и сохраняет примеры всех типов файлов в корневой ФС (`-`, `b`, `c`, `d`, `l`, `p`, `s`) с использованием `ls -lR>

### Задание 2 — Жесткие ссылки
Поиск всех жёстких ссылок на файл через `stat`, `ls -iR` и `grep`. Скрипт `lab1_task2.sh`.

### Задание 3–4 — Символические ссылки
Создание символьных ссылок разными способами (`ln -s`, `cp -s`, `link`) и их автоматический поиск. Скрипт `lab1_task3.sh`.

### Задание 5 — Утилита `find`
Разнообразный поиск файлов по дате, размеру, имени, пустоте, через `-exec` и `-printf`.

### Задание 6 — Заголовки файлов
Анализ структуры PDF, Python и Pickle файлов, а также директорий с помощью `hexdump` и `od`.

### Задание 7 — Размер каталога
Эксперимент с изменением размера каталога при добавлении и удалении большого числа файлов. Скрипт `lab1_task7.sh`.

### Задание 8 — /etc/passwd, /etc/shadow
Анализ прав доступа и структуры этих файлов. Проверка прав доступа у `/usr/bin/passwd`.

### Задание 9 — Права доступа и SUID/SGID
- Изучить и продемонстрировать изменение прав доступа к файлам (`chmod`, `chown`, `umask`).
- Установить SUID-бит на программу, чтобы она выполнялась от имени владельца (root).
- Экспериментально проверить, как итоговые права меняются при разных правах пользователя и группы.

### Задание 10 — Программа-шлюз
- Написать на C программу, которая даёт доступ к файлу другого пользователя без прямых прав чтения.
- Реализовать аналог `passwd`, где программа имеет флаг SUID root и позволяет безопасно получать содержимое закрытого файла.

### Задание 11 — Файловые системы и монтирование
- Изучить команды `df`, `lsblk`, `mount`, `cat /etc/mtab`, `cat /proc/mounts` для получения информации о ФС.
- Проанализировать точки монтирования, типы и размеры ФС, а также структуру GPT-разделов диска.
- Найти максимально возможный путь (PATH_MAX), проанализировать, где это ограничение указывается.

### Задание 12 — Утилита `file`
- **12.1** Исследовать принцип работы `file`, посмотреть расположение базы `magic` (обычно `/usr/share/file/magic` или `/etc/magic`).
- **12.2** Применить различные ключи (`-i`, `-b`, `-z`, `-k`) и показать, как `file` распознаёт разные типы файлов (PDF, ELF, текст).
- **12.3** Добавить собственное определение типа файла в базу `magic`, проверить его работу командой:
  ```bash
  file -m ./my_magic test_custom_file
  test_custom_file: My Custom File Type




# Лабораторная работа 2 «Управление процессами и потоками в Linux»

> **Цель:** освоить базовые и продвинутые приёмы работы с процессами, потоками, планировщиком и наследованием ресурсов в ОС Linux. Итогом стала коллекция небольших утилит‑примеров, сопровождаемая лог‑файлами экспериментов.

---

## 0. Предварительные сведения

* **Аппаратная платформа:** 13th Gen Intel i7-13650HX (20) @ 4.700GHz.
* **ОС:** Debian GNU/Linux 12 (bookworm) x86_64
* **Сборка:** `gcc <file>.c -o <prog> -pthread` (для POSIX‑потоков) или дополнительно с `-D_GNU_SOURCE`, если требуется `clone()`.

Файловая структура проекта

```
lab2/
 ├─ task1 … task6        # каталоги по пунктам задания
 ├─ logs/                # итоговые журналы экспериментов
 └─ README.md            # текущий документ
```

---

## 1. Управление заданиями (shell‑практика)

| Подпункт | Изучено                                              | Практика                                                 |
| -------: | ---------------------------------------------------- | -------------------------------------------------------- |
|  **1.1** | фоновые задания, `jobs`, `fg/bg`, `notify`           | запущено 3 `sleep`, управление приоритетом и завершением |
|  **1.2** | демонстрация *неотключаемых* процессов через `nohup` | сеанс завершён → процессы «пережили» logout              |
|  **1.3** | диапазоны `uid/pid`, системные учётные записи        | просмотр `/etc/passwd`, `/proc/sys/kernel/pid_max`       |
|  **1.4** | отличия системных процессов                          | фильтр по владельцу `root`, анализ `pstree`              |
|  **1.5** | изучение метрик процесса через `/proc`               | анализ `status`, `environ`, `fd` каталога alacritty      |

*Пример вывода логов:* см. `lab2.log`

---

## 2. Порождение процессов

### 2.1 Однофайловый пример `single.c/multiple.c`

`fork()` → родитель/дитя считают выражения.
`multiple.c` — конкуренция в цикле, выводит `PID`+итерацию.

### 2.2 Раздельные файлы `father.c` / `son.c`

Запуск как foreground и background, лог `process_log.txt` фиксирует дерево процессов через `system("ps -l > file")`.

### 2.3 Семейство `exec*()`

Шесть вызовов (`execl`, `execv`, `execle`, …) продемонстрировали различную передачу argv/envp.

### 2.4 Ситуации orphans/zombies

`father_2_4.c` моделирует три сценария: **a)** wait; **b)** orphan; **c)** zombie.

Код `father_2_4.c` citeturn3file0.

---

## 3. Сигналы

`father` порождает `son1‑3`; каждая программа реагирует на `SIGUSR1` по‑разному: default / ignore / custom handler.
Лог до/после сигналов показал статус «defunct» для `son1`, подтверждая реакцию по умолчанию.

---

## 4. Потоки

### 4.1 Создание потоков `pthread` и `clone`

Программа `task_4_1.c` выводит `PID/TID`, затем печатает `ps -eLf`. Все TID принадлежат одному PID.

### 4.2 Анализ наследуемых параметров (см. логи)

### 4.3 Разделяемые ресурсы

* **Глобальная переменная и FILE** — пример `task_4_3.c`.
* **Файловые дескрипторы** — утилита `task_4_3_fd.c` (см. ниже). Потоки делят `dup2`‑созданный `fd 3`; каждое обращение к `write(3, …)` немедленно видно в терминале.

> Запуск:
>
> ```bash
> gcc task_4_3_fd.c -o task_4_3_fd -pthread
> ./task_4_3_fd
> ```
>
> На экране: адрес `global_var` совпадает, а список `/proc/<pid>/fd` одинаков у всех TID.

### 4.4 Убийство потока через `kill <TID>`

`SIGUSR1` обработан одним потоком, второй остался жив, что показало – сигнал направляется конкретному LWP.

---

## 5. Планирование

| Пункт   | Что проверялось                                                      | Ключевые файлы                    |
| ------- | -------------------------------------------------------------------- | ----------------------------------|
| **5.1** | политика/приоритет по умолчанию (`SCHED_OTHER`, nice 0)              | `scheduler_info.c`, `experiment.c`|
| **5.2** | изменение nice и реакция `getpriority()`                             | `experiment_5_2.c`                |
| **5.3** | `SCHED_FIFO`, равные / разные приоритеты, границы 1‑99               | `experiment_fifo.c`               |
| **5.4** | `SCHED_RR`, квант (`sched_rr_get_interval` ≈ 20 ms), `sched_yield()` | `experiment_5_4.c`                |
| **5.5** | конкуренция RR vs OTHER при одинаковом приоритете                    | `experiment_5_5.c`                |
| **5.6** | планирование внутри *потоков* одного процесса                        | `task_5_6.c`                      |

Главный вывод: без прав root изменить политику невозможно (EPERM). Под `sudo` эффекты наглядны: FIFO — строгая последовательность, RR — циклическая с квантом≈20 мс.

---

## 6. Наследование ресурсов

| Пункт   | Эксперимент                  | Итог                                                                                      |
| ------- | ---------------------------- | ------------------------------------------------------------------------------------------|
| **6.1** | общий fd при `fork()/exec()` | файл открыт в родителе → доступен после `exec`                                            |
| **6.2** | политика планирования        | `SCHED_OTHER` наследуется и после `exec`                                                  |
| **6.3** | диспозиции сигналов          | custom‑handler сброшен после `exec`, IGN остался                                          |
| **6.4** | `clone()` и CLONE\_VM        | с `CLONE_VM` глобальная переменная изменилась и в родителе; без флага изменение локально  |

---

## Запуск всех примеров

```
cd lab2/task<N>
make               # при наличии Makefile
# или
gcc file.c -o prog -pthread
./prog [args]
```

Используйте `taskset -c 0` для однопроцессорного режима.
Для экспериментов FIFO/RR требуется `sudo` (cap\_sys\_nice).

---

## Что изучено

* **fork/exec/wait** — механика создания, ожидания и замены образа процесса.
* **Сигналы** — типовые реакции и их наследование.
* **POSIX threads vs. clone** — различия в уровне абстракции, флаги совместного адресного пространства.
* **Планировщик Linux** — политики `SCHED_OTHER / FIFO / RR`, nice‑уровни, квант времени.
* **/proc FS** — практическая диагностика: fd‑каталог, статус, environ.
* **Наследование ресурсов** — файлы, приоритеты, диспозиции сигналов и адресное пространство.

---

## Заметки

* Демонстрации проводились на *одном ядре* во избежание неявного параллелизма.
* Все логи сохранены в `lab2.log` для проверки (600+ строк).
* Код писался в образовательных целях; проверка ошибок I/O минимальна.







# Лабораторная работа №3: IPC в Linux (POSIX)

## Цель работы

Познакомиться с основными средствами межпроцессного взаимодействия (IPC) в Linux — сигналами, разделяемой памятью, каналами, очередями сообщений и сокетами — и на практике реализовать мини-примеры, измерить ограничения и производительность.

## Выполненные задания

| №   | Тема                                | Файлы                                                        | Кратко                                                                                                  |
| --- | ----------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------- |
| 1.1 | Сигналы: SIGUSR1 без обработчика    | `sigusr_1_1.c`                                               | Таймер через 2 с отправляет SIGUSR1 второму потоку; сигнал завершает весь процесс.                      |
| 1.2 | Сигналы: пользовательский handler   | `sigusr_1_2.c`                                               | Обработчик SIGUSR1 во втором потоке печатает время и вызывает `pthread_exit`; завершается только поток. |
| 3.1 | `sigaction()`, маскирование         | `sigaction_3_1.c`                                            | Handler SIGINT блокирует SIGUSR1, затем восстанавливается default-действие.                             |
| 5.1 | Shared memory + семафоры (процессы) | `shm_sync_5_1.c`                                             | Producer/Consumer без busy-wait, порядок гарантирован.                                                  |
| 5.2 | Процессы: sem vs mutex/cond         | `shm_sync_sem_5_2.c`, `shm_sync_mutex_5_2.c`                 | 100 000 сообщений: sem ≈ 800 мс, mutex ≈ 870 мс.                                                        |
| 5.3 | Потоки: sem vs mutex/cond           | `shm_sync_threads_sem_5_3.c`, `shm_sync_threads_mutex_5_3.c` | sem ≈ 870 мс, mutex ≈ 857 мс.                                                                           |
| 6.1 | Анонимные pipe                      | `pipe_example_6_1.c`                                         | Fork, запись → чтение; ограничения pipe.                                                                |
| 6.2 | FIFO (именн. канал)                 | `fifo_example_6_2.c`                                         | `mkfifo`, `stat`, writer/reader.                                                                        |
| 6.3 | POSIX mqueue                        | `mq_example_6_3.c`                                           | Очередь как «почтовый ящик» с `O_NONBLOCK`.                                                             |
| 7.1 | TCP-сокеты локально                 | `server_tcp_7_1.c`, `client_tcp_7_1.c`                       | Обмен «Hello…» по 127.0.0.1:5000.                                                                       |
| 7.2 | UDP-сокеты локально                 | `server_udp_7_2.c`, `client_udp_7_2.c`                       | Обмен по 127.0.0.1:5001.                                                                                |

## Основные выводы

* **Сигналы**: маскирование в `sa_mask` позволяет откладывать доставку сигналов, `pthread_kill` адресует сигнал конкретной нити.
* **Shared memory**: POSIX sem быстрее при процессах, но в потоках futex-базированный mutex/cond обгоняет sem.
* **Pipe vs FIFO**: анонимный pipe действует только в пределах дерева процессов; FIFO — именной файл, доступен любым процессам.
* **Очереди сообщений**: с `O_NONBLOCK` легко реализовать «почтовый ящик» без прямой синхронизации отправителя и получателя.
* **Сокеты**: TCP гарантирует доставку, UDP легче и быстрее для простых datagram; системные лимиты (`somaxconn`, `msgsize`, `rmem/wmem`) критически влияют на масштабирование.

## Демонстрация системных ограничений

```bash
ulimit -n                       # 1024  (FD per-process)
grep '^#define UNIX_PATH_MAX' /usr/include/linux/un.h  # 108
cat /proc/sys/net/core/somaxconn             # 4096
echo 'net.core.somaxconn = 1024' | sudo tee -a /etc/sysctl.conf
sudo sysctl -p /etc/sysctl.conf              # применить
```

`/etc/sysctl.conf`, `/proc/sys/net/*`, `/etc/security/limits.conf` — основные места конфигурации лимитов.

## Сборка и запуск примеров

```bash
# Сигналы
gcc sigusr_1_2.c -pthread -o sig2 && ./sig2

# Shared memory sem vs mutex
gcc -pthread shm_sync_sem_5_2.c    -o sem_test
gcc -pthread shm_sync_mutex_5_2.c  -o mtx_test
./sem_test
./mtx_test

# TCP сервер/клиент
gcc server_tcp_7_1.c -o tcp_server
./tcp_server &
 gcc client_tcp_7_1.c -o tcp_client && ./tcp_client
```

(Аналогично для других файлов.)

## Структура репозитория

```
├── 1_signals/
│   ├── sigusr_1_1.c
│   └── sigusr_1_2.c
├── 3_sigaction/
│   └── sigaction_3_1.c
├── 5_shared_memory/
│   ├── shm_sync_5_1.c
│   ├── shm_sync_sem_5_2.c
│   ├── shm_sync_mutex_5_2.c
│   ├── shm_sync_threads_sem_5_3.c
│   └── shm_sync_threads_mutex_5_3.c
├── 6_pipes_fifo_mqueue/
│   ├── pipe_example_6_1.c
│   ├── fifo_example_6_2.c
│   └── mq_example_6_3.c
├── 7_sockets/
│   ├── server_tcp_7_1.c  client_tcp_7_1.c
│   ├── server_udp_7_2.c  client_udp_7_2.c
└── README.md
```

---

© 2025, студент ФКТИ, направления ПМИ, Щеглов Михаил, ЛЭТИ
